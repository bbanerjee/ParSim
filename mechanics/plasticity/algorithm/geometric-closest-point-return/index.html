<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Geometric closest point return algorithm - Parresia Simulations</title>
<meta name="description" content="Part 8 of the series on plasticity return algorithms">


  <meta name="author" content="Biswajit Banerjee">
  
  <meta property="article:author" content="Biswajit Banerjee">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Parresia Simulations">
<meta property="og:title" content="Geometric closest point return algorithm">
<meta property="og:url" content="https://bbanerjee.github.io/ParSim/mechanics/plasticity/algorithm/geometric-closest-point-return/">


  <meta property="og:description" content="Part 8 of the series on plasticity return algorithms">







  <meta property="article:published_time" content="2017-03-31T23:30:00+13:00">





  

  


<link rel="canonical" href="https://bbanerjee.github.io/ParSim/mechanics/plasticity/algorithm/geometric-closest-point-return/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Biswajit Banerjee",
      "url": "https://bbanerjee.github.io/ParSim/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/ParSim/feed.xml" type="application/atom+xml" rel="alternate" title="Parresia Simulations Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/ParSim/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<link rel="stylesheet" href="https://bbanerjee.github.io/ParSim/assets/css/parresia.css">

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <script type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML">
  </script>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/ParSim/"><img src="/ParSim/assets/img/ParresiaLogoSep2017_plain.png" alt=""></a>
        
        <a class="site-title" href="/ParSim/">
          Parresia Simulations
          <span class="site-subtitle">Parallel particle and finite element simulation</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/ParSim/docs/articles/">Blog articles</a>
            </li><li class="masthead__menu-item">
              <a href="/ParSim/docs/parsim/">ParSim software</a>
            </li><li class="masthead__menu-item">
              <a href="/ParSim/docs/material-data/">Material data</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Biswajit Banerjee</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>PhD Mechanical Engineering</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Auckland, NZ</span>
        </li>
      

      
        
          
            <li><a href="mailto:b.banerjee.nz@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Geometric closest point return algorithm">
    <meta itemprop="description" content="IntroductionIn Part 7, we saw thatfor isotropic elastic materials and perfect associated plasticity, the trial stressand the actual stress are at the shortest distance from each other in a transformed stressspace.  We also saw that the transformed stress can be expressed as">
    <meta itemprop="datePublished" content="2017-03-31T23:30:00+13:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Geometric closest point return algorithm
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Contents</h4></header>
              <ul class="toc__menu">
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#the-arena-yield-function">The Arena yield function</a></li>
  <li><a href="#the-non-hardening-return-algorithm">The non-hardening return algorithm</a></li>
  <li><a href="#the-closest-point-algorithm">The closest point algorithm</a></li>
  <li><a href="#an-animation-of-the-closest-point-algorithm">An animation of the closest point algorithm</a></li>
</ul>

            </nav>
          </aside>
        
        <h5 id="introduction">Introduction</h5>
<p>In <a href="/ParSim/mechanics/plasticity/algorithm/closest-point-return/">Part 7</a>, we saw that
for isotropic elastic materials and perfect associated plasticity, the trial stress
and the actual stress are at the shortest distance from each other in a transformed stress
space.  We also saw that the transformed stress can be expressed as
<!--more--></p>
<div>
$$
  \boldsymbol{\sigma}^\star 
  = \frac{z}{\sqrt{3\kappa}}\,\mathbf{E}_z +
    \frac{r}{\sqrt{2\mu}}\,\mathbf{E}_r
$$
</div>
<p>where</p>
<div>
$$
  z = \tfrac{1}{\sqrt{3}}\,\text{tr}(\boldsymbol{\sigma}) ~,~~
  r = \lVert \boldsymbol{s} \rVert 
$$
</div>
<p>and</p>
<div>
$$
  \mathbf{E}_z = \tfrac{1}{\sqrt{3}}\,\mathbf{I} ~,~~
  \mathbf{E}_r = \frac{\boldsymbol{s}}{\lVert\boldsymbol{s}\rVert} \,.
$$
</div>
<p>We can show that the transformed stress vector remains geometrically unchanged (in the sense that
angles are unchanged) if we express it as</p>
<div class="notice">
$$
  \boldsymbol{\sigma}^\star 
  = z\,\mathbf{E}_z + \sqrt{\frac{3\kappa}{2\mu}}\,r\,\mathbf{E}_r
  =: z\,\mathbf{E}_z + r'\,\mathbf{E}_r
$$
</div>
<p>This observation can be used to perform a purely geometric stress update that can
be quite efficient for nonlinear Drucker-Prager plasticity and many other phenomenological
plasticity models.  Let us see how this concept has been applied to the <a href="https://github.com/bbanerjee/ParSim/blob/master/Vaango/src/CCA/Components/MPM/ConstitutiveModel/Arenisca3PartiallySaturated.cc">Arena plasticity
model</a>.</p>

<h5 id="the-arena-yield-function">The Arena yield function</h5>
<p>The Arena model is an extension to partially saturated soils of the Arenisca model
developed by R. M. Brannon and co-workers.  The yield function used by this model is a
nonlinear Drucker-Prager model with a compression cap.  Further details can be found in
the <a href="https://github.com/bbanerjee/ParSim/tree/master/Vaango/Manuals/TheoryGuide/ArenaSoil">Arena theory manual</a>.</p>

<p>If the volumetric and deviatoric components of the total stress are</p>
<div>
$$
    \bar{p} := -\tfrac{1}{3} \text{tr}(\boldsymbol{\sigma}) \quad \text{and} \quad \boldsymbol{s} := \boldsymbol{\sigma} + \bar{p} \mathbf{I}
$$
</div>
<p>we can define</p>
<div>
$$
  \begin{align}
    \bar{p}_\text{eff} &amp; := -\tfrac{1}{3} \text{tr}(\boldsymbol{\sigma}_\text{eff}) = \bar{p} - B \bar{p}^w \\
    \boldsymbol{s}_\text{eff} &amp; := \boldsymbol{\sigma}_\text{eff} + \bar{p}_\text{eff} \mathbf{I} = \boldsymbol{\sigma} + \bar{p} \mathbf{I} = \boldsymbol{s} \\
    J_2^\text{eff} &amp; := \tfrac{1}{2} \boldsymbol{s}_\text{eff}:\boldsymbol{s}_\text{eff}  \,.
  \end{align}
$$
</div>
<p>Then the Arena yield function is</p>
<div class="notice">
$$
     f(\boldsymbol{\sigma}, B, \bar{p}^w, \bar{X}) =
       \sqrt{J_2^\text{eff}} - F_f(\bar{p}_\text{eff}) \, F_c(\bar{p}_\text{eff}, \bar{X})
$$
</div>
<p>where</p>
<div class="notice">
$$
    F_f(\bar{p}_\text{eff})  = a_1 - a_3 \exp[- 3 a_2 \bar{p}_\text{eff}] + 3 a_4 \bar{p}_\text{eff}
$$
</div>
<p>and</p>
<div class="notice">
$$
    F_c(\bar{p}_\text{eff}, \bar{X})  =
       \begin{cases}
         1 &amp; \quad \text{for}\quad 3\bar{p}_\text{eff} \le \bar{\kappa} \\
         \sqrt{1 - \left(\cfrac{3\bar{p}_\text{eff} - \bar{\kappa}}{\bar{X}_\text{eff} - \bar{\kappa}}\right)^2} &amp;
           \quad \text{for}\quad 3\bar{p}_\text{eff} &gt; \bar{\kappa} \,.
       \end{cases}
$$
</div>
<p>Here \(a_i\) are material parameters, \(\bar{X}_\text{eff}(\boldsymbol{\varepsilon}^p, B, \bar{p}^w) = \bar{X} - 3B\bar{p}^w\) is the
shifted form of the apparent hydrostatic compressive strength (\(\bar{X}/3\)) of the partially saturated
material, and \(\bar{\kappa}\) is the branch point at which the cap function \(F_c\) starts decreasing until it
reaches the hydrostatic strength point (\(\bar{X}\)):</p>
<div class="notice">
$$
    \bar{\kappa} = 3\bar{p}_\text{eff}^\text{peak} - (3\bar{p}_\text{eff}^\text{peak} - \bar{X}_\text{eff}) R_c
$$
</div>
<p>where \(\bar{p}_\text{eff}^\text{peak}\) is the maximum hydrostatic tensile stress that the material can
support and \(R_c\) is a cap ratio.</p>

<h5 id="the-non-hardening-return-algorithm">The non-hardening return algorithm</h5>
<p>We use the closest-point return approach discussed in the previous articles in this series to
compute a return to the yield surface while keeping all internal variables fixed.
The pseudocsode of the algorithm is listed below:</p>
<div class="notice--info">
$$
  \begin{align}
    &amp;\text{Require:} &amp;&amp; \boldsymbol{\sigma}^k, \delta\boldsymbol{\varepsilon}, X^k, K^k, G^k,
                          (\bar{p}^w)^k, \boldsymbol{s}^\text{trial}, \sqrt{J_2^\text{trial}},
                          r^\text{trial}, z_\text{eff}^\text{trial}, \\
    &amp;                &amp;&amp;  a_1, a_2, a_3, a_4, I_1^\text{peak}, R_c \\
    &amp;\text{Procedure:} &amp;&amp; \text{nonHardeningReturn} \\
    &amp;   1.\quad &amp;&amp;   r'_\text{trial} \leftarrow r^\text{trial} \sqrt{\cfrac{3K^k}{2G^k}}
                \qquad \mbox{Transform the trial $r$ coordinate} \\
    &amp;   2.\quad &amp;&amp;   X_\text{eff}^k \leftarrow X^k + 3 (\bar{p}^w)^k \\
    &amp;   3.\quad &amp;&amp;   z_\text{eff}^\text{closest}, r'_\text{closest} \leftarrow
           \text{getClosestPoint}(K^k, G^k, X_\text{eff}^k, a_1, a_2, a_3, a_4,\\
    &amp;      &amp;&amp;   \qquad \qquad\qquad I_1^\text{peak}, R_c, z_\text{eff}^\text{trial}, r'_\text{trial}) \\
    &amp;   4.\quad &amp;&amp;   I_1^{\text{closest}} \leftarrow \sqrt{3} z_\text{eff}^\text{closest} - 3 (\bar{p}^w)^k,
              \sqrt{J_2^\text{closest}} \leftarrow \sqrt{\frac{G^k}{3K^k}}\,r'_\text{closest} \\
    &amp;   5.\quad &amp;&amp;  \text{If} {\sqrt{J_2^\text{trial}} &gt; 0} \\
    &amp;      6. &amp;&amp;  \qquad \boldsymbol{\sigma}^\text{fixed} = \tfrac{1}{3} I_1^{\text{closest}} \mathbf{I} +
          \frac{\sqrt{J_2^\text{closest}}}{\sqrt{J_2^\text{trial}}}\,\boldsymbol{s}^\text{trial} \\
    &amp;         &amp;&amp;  \qquad \mbox{Compute updated total stress} \\
    &amp;   7.\quad &amp;&amp;  \text{Else} \\
    &amp;      8. &amp;&amp;  \qquad \boldsymbol{\sigma}^\text{fixed} = \tfrac{1}{3} I_1^{\text{closest}} \mathbf{I} +
                  \boldsymbol{s}^\text{trial}\\
    &amp;         &amp;&amp; \qquad
                \mbox{Compute updated total stress from hydrostatic trial stress} \\
    &amp;   9.\quad &amp;&amp;  \text{EndIf} \\
    &amp;   10.\quad &amp;&amp;  \delta\boldsymbol{\sigma}_\text{fixed} \leftarrow \boldsymbol{\sigma}^\text{fixed} -
              \boldsymbol{\sigma}^k \qquad \mbox{Compute stress increment} \\
    &amp;   11.\quad &amp;&amp;  \delta\boldsymbol{\sigma}_\text{fixed}^\text{iso} \leftarrow \tfrac{1}{3}
                \text{tr}(\delta\boldsymbol{\sigma}_\text{fixed}) \mathbf{I}, 
         \quad \delta\boldsymbol{\sigma}_\text{fixed}^\text{dev} \leftarrow
          \delta\boldsymbol{\sigma}_\text{fixed} - \delta\boldsymbol{\sigma}_\text{fixed}^\text{iso} \\
    &amp;   12.\quad &amp;&amp;  \delta\boldsymbol{\varepsilon}^{p,\text{fixed}} = \delta\boldsymbol{\varepsilon} -
             \frac{1}{3K^k}\,\delta\boldsymbol{\sigma}_\text{fixed}^\text{iso} -
             \frac{1}{2G^k}\,\delta\boldsymbol{\sigma}_\text{fixed}^\text{dev} \\
    &amp;    &amp;&amp;    \quad\mbox{Compute plastic strain increment} \\
    &amp;   13.\quad &amp;&amp;  \text{Return} \qquad \boldsymbol{\sigma}^\text{fixed}, \delta\boldsymbol{\varepsilon}^{p,\text{fixed}} \\
  \end{align}
$$
</div>

<h5 id="the-closest-point-algorithm">The closest point algorithm</h5>
<p>Let us look at the actual implementation to get a feel for how the closest point can be found
geometrically.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">bool</span>
<span class="n">YieldCond_Arena</span><span class="o">::</span><span class="n">getClosestPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">ModelState_Arena</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span> <span class="c1">// The plasticity state</span>
                                 <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">px</span><span class="p">,</span>              <span class="c1">// The trial stress z, r'</span>
                                 <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">py</span><span class="p">,</span>
                                 <span class="kt">double</span><span class="o">&amp;</span> <span class="n">cpx</span><span class="p">,</span>                   <span class="c1">// The closest point z, r'</span>
                                 <span class="kt">double</span><span class="o">&amp;</span> <span class="n">cpy</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Point</span> <span class="n">pt</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">Point</span> <span class="n">closest</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">getClosestPointGeometricBisect</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">closest</span><span class="p">);</span>
  <span class="n">cpx</span> <span class="o">=</span> <span class="n">closest</span><span class="p">.</span><span class="n">x</span><span class="p">();</span>
  <span class="n">cpy</span> <span class="o">=</span> <span class="n">closest</span><span class="p">.</span><span class="n">y</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The bisection algorithm for the closest point can be implemented as shown below.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">getClosestPointGeometricBisect</span><span class="p">(</span><span class="k">const</span> <span class="n">ModelState_Arena</span><span class="o">*</span> <span class="n">state</span><span class="p">,</span>
                                                    <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">z_r_pt</span><span class="p">,</span>
                                                    <span class="n">Point</span><span class="o">&amp;</span> <span class="n">z_r_closest</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Get the particle specific internal variables from the model state</span>
  <span class="c1">// Store in a local struct</span>
  <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">yieldParams</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">"PEAKI1"</span><span class="p">);</span>
  <span class="p">................</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">limitParameters</span> <span class="o">=</span>
    <span class="n">computeModelParameters</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span><span class="p">,</span> <span class="n">d_local</span><span class="p">.</span><span class="n">FSLOPE</span><span class="p">,</span> <span class="n">d_local</span><span class="p">.</span><span class="n">STREN</span><span class="p">,</span> <span class="n">d_local</span><span class="p">.</span><span class="n">YSLOPE</span><span class="p">);</span>
  <span class="n">d_local</span><span class="p">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">limitParameters</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">d_local</span><span class="p">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">limitParameters</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="p">................</span>

  <span class="c1">// Get the plastic internal variables from the model state</span>
  <span class="kt">double</span> <span class="n">pbar_w</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">pbar_w</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">X_eff</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">capX</span> <span class="o">+</span> <span class="mf">3.0</span><span class="o">*</span><span class="n">pbar_w</span><span class="p">;</span>

  <span class="c1">// Compute kappa</span>
  <span class="kt">double</span> <span class="n">I1_diff</span> <span class="o">=</span> <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">-</span> <span class="n">X_eff</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">kappa</span> <span class="o">=</span>  <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">-</span> <span class="n">d_local</span><span class="p">.</span><span class="n">CR</span><span class="o">*</span><span class="n">I1_diff</span><span class="p">;</span>

  <span class="c1">// Get the bulk and shear moduli and compute sqrt(3/2 K/G)</span>
  <span class="kt">double</span> <span class="n">sqrtKG</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.5</span><span class="o">*</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">bulkModulus</span><span class="o">/</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">shearModulus</span><span class="p">);</span>

  <span class="c1">// Compute diameter of yield surface in z-r space</span>
  <span class="kt">double</span> <span class="n">sqrtJ2_diff</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">evalYieldConditionMax</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">yield_surf_dia_zrprime</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">I1_diff</span><span class="o">*</span><span class="n">one_sqrt_three</span><span class="p">,</span> <span class="n">sqrtJ2_diff</span><span class="o">*</span><span class="n">sqrt_two</span><span class="o">*</span><span class="n">sqrtKG</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">dist_to_trial_zr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">z_r_pt</span><span class="p">.</span><span class="n">x</span><span class="p">()</span><span class="o">*</span><span class="n">z_r_pt</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">+</span> <span class="n">z_r_pt</span><span class="p">.</span><span class="n">y</span><span class="p">()</span><span class="o">*</span><span class="n">z_r_pt</span><span class="p">.</span><span class="n">y</span><span class="p">());</span>
  <span class="kt">double</span> <span class="n">dist_dia_ratio</span> <span class="o">=</span> <span class="n">dist_to_trial_zr</span><span class="o">/</span><span class="n">yield_surf_dia_zrprime</span><span class="p">;</span>

  <span class="c1">// Set the number of points used to discretize the yield surface</span>
  <span class="kt">int</span> <span class="n">num_points</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">ceil</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="n">dist_dia_ratio</span><span class="p">)));</span>

   <span class="c1">// Set up I1 limits</span>
  <span class="kt">double</span> <span class="n">I1eff_min</span> <span class="o">=</span> <span class="n">X_eff</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">I1eff_max</span> <span class="o">=</span> <span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span><span class="p">;</span>

  <span class="c1">// Set up bisection</span>
  <span class="kt">double</span> <span class="n">eta_lo</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">eta_hi</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

  <span class="c1">// Set up mid point</span>
  <span class="kt">double</span> <span class="n">I1eff_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">I1eff_min</span> <span class="o">+</span> <span class="n">I1eff_max</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">eta_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">eta_lo</span> <span class="o">+</span> <span class="n">eta_hi</span><span class="p">);</span>

  <span class="c1">// Do bisection</span>
  <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">TOLERANCE</span> <span class="o">=</span> <span class="mf">1.0e-10</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">z_r_points</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">z_r_segments</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">z_r_segment_points</span><span class="p">;</span>
  <span class="n">Point</span> <span class="n">z_r_closest_old</span><span class="p">;</span>
  <span class="n">z_r_closest_old</span><span class="p">.</span><span class="n">x</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
  <span class="n">z_r_closest_old</span><span class="p">.</span><span class="n">y</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
  <span class="n">z_r_closest_old</span><span class="p">.</span><span class="n">z</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">eta_hi</span> <span class="o">-</span> <span class="n">eta_lo</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">TOLERANCE</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// Get the yield surface points</span>
    <span class="n">z_r_points</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">getYieldSurfacePointsAll_RprimeZ</span><span class="p">(</span><span class="n">X_eff</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">sqrtKG</span><span class="p">,</span> <span class="n">I1eff_min</span><span class="p">,</span> <span class="n">I1eff_max</span><span class="p">,</span>
                                     <span class="n">num_points</span><span class="p">,</span> <span class="n">z_r_points</span><span class="p">);</span>

    <span class="c1">// Find the closest point</span>
    <span class="n">findClosestPoint</span><span class="p">(</span><span class="n">z_r_pt</span><span class="p">,</span> <span class="n">z_r_points</span><span class="p">,</span> <span class="n">z_r_closest</span><span class="p">);</span>

    <span class="c1">// Compute I1 for the closest point</span>
    <span class="kt">double</span> <span class="n">I1eff_closest</span> <span class="o">=</span> <span class="n">sqrt_three</span><span class="o">*</span><span class="n">z_r_closest</span><span class="p">.</span><span class="n">x</span><span class="p">();</span>

    <span class="c1">// If (I1_closest &lt; I1_mid)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I1eff_closest</span> <span class="o">&lt;</span> <span class="n">I1eff_mid</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">I1eff_max</span> <span class="o">=</span> <span class="n">I1eff_mid</span><span class="p">;</span>
      <span class="n">eta_hi</span> <span class="o">=</span> <span class="n">eta_mid</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">I1eff_min</span> <span class="o">=</span> <span class="n">I1eff_mid</span><span class="p">;</span>
      <span class="n">eta_lo</span> <span class="o">=</span> <span class="n">eta_mid</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">I1eff_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">I1eff_min</span> <span class="o">+</span> <span class="n">I1eff_max</span><span class="p">);</span>
    <span class="n">eta_mid</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">eta_lo</span> <span class="o">+</span> <span class="n">eta_hi</span><span class="p">);</span>

    <span class="c1">// Distance to old closest point</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iters</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">z_r_closest</span> <span class="o">-</span> <span class="n">z_r_closest_old</span><span class="p">).</span><span class="n">length2</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.0e-16</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">z_r_closest_old</span> <span class="o">=</span> <span class="n">z_r_closest</span><span class="p">;</span>

    <span class="o">++</span><span class="n">iters</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The yield surface points are computed using</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">getYieldSurfacePointsAll_RprimeZ</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">X_eff</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">kappa</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">sqrtKG</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_min</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_max</span><span class="p">,</span>
                                                      <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">num_points</span><span class="p">,</span>
                                                      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">z_r_vec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Compute z_eff and r'</span>
  <span class="n">computeZeff_and_RPrime</span><span class="p">(</span><span class="n">X_eff</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">sqrtKG</span><span class="p">,</span> <span class="n">I1eff_min</span><span class="p">,</span> <span class="n">I1eff_max</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">z_r_vec</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">computeZeff_and_RPrime</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">X_eff</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">kappa</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">sqrtKG</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_min</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">I1eff_max</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">num_points</span><span class="p">,</span>
                                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">z_r_vec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Set up points</span>
  <span class="kt">double</span> <span class="n">rad</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">-</span> <span class="n">X_eff</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">cen</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">PEAKI1</span> <span class="o">+</span> <span class="n">X_eff</span><span class="p">);</span>
  <span class="kt">double</span> <span class="n">theta_max</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">((</span><span class="n">I1eff_min</span> <span class="o">-</span> <span class="n">cen</span><span class="p">)</span><span class="o">/</span><span class="n">rad</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">));</span>
  <span class="kt">double</span> <span class="n">theta_min</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">((</span><span class="n">I1eff_max</span> <span class="o">-</span> <span class="n">cen</span><span class="p">)</span><span class="o">/</span><span class="n">rad</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">));</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">theta_vec</span><span class="p">;</span>
  <span class="n">linspace</span><span class="p">(</span><span class="n">theta_min</span><span class="p">,</span> <span class="n">theta_max</span><span class="p">,</span> <span class="n">num_points</span><span class="p">,</span> <span class="n">theta_vec</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">theta</span> <span class="o">:</span> <span class="n">theta_vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">I1_eff</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">cen</span> <span class="o">+</span> <span class="n">rad</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">X_eff</span><span class="p">);</span>


    <span class="c1">// Compute F_f</span>
    <span class="kt">double</span> <span class="n">Ff</span> <span class="o">=</span> <span class="n">d_local</span><span class="p">.</span><span class="n">a1</span> <span class="o">-</span> <span class="n">d_local</span><span class="p">.</span><span class="n">a3</span><span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">exp</span><span class="p">(</span><span class="n">d_local</span><span class="p">.</span><span class="n">a2</span><span class="o">*</span><span class="n">I1_eff</span><span class="p">)</span> <span class="o">-</span> <span class="n">d_local</span><span class="p">.</span><span class="n">a4</span><span class="o">*</span><span class="p">(</span><span class="n">I1_eff</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">Ff_sq</span> <span class="o">=</span> <span class="n">Ff</span><span class="o">*</span><span class="n">Ff</span><span class="p">;</span>

    <span class="c1">// Compute Fc</span>
    <span class="kt">double</span> <span class="n">Fc_sq</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I1_eff</span> <span class="o">&lt;</span> <span class="n">kappa</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">double</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">-</span> <span class="n">I1_eff</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">kappa</span> <span class="o">-</span> <span class="n">X_eff</span><span class="p">);</span>
      <span class="n">Fc_sq</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratio</span><span class="o">*</span><span class="n">ratio</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Compute J2</span>
    <span class="kt">double</span> <span class="n">J2</span> <span class="o">=</span> <span class="n">Ff_sq</span><span class="o">*</span><span class="n">Fc_sq</span><span class="p">;</span>
    <span class="n">z_r_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">I1_eff</span><span class="o">/</span><span class="n">sqrt_three</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">J2</span><span class="p">)</span><span class="o">*</span><span class="n">sqrtKG</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>And, finally, the actual geometric closest point algorithm is</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span>
<span class="n">YieldCond_MasonSand</span><span class="o">::</span><span class="n">findClosestPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&amp;</span> <span class="n">poly</span><span class="p">,</span>
                                      <span class="n">Point</span><span class="o">&amp;</span> <span class="n">min_p</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">TOLERANCE_MIN</span> <span class="o">=</span> <span class="mf">1.0e-12</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">XP</span><span class="p">;</span>

  <span class="c1">// Loop through the segments of the polyline</span>
  <span class="k">auto</span> <span class="n">iterStart</span> <span class="o">=</span> <span class="n">poly</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">iterEnd</span>   <span class="o">=</span> <span class="n">poly</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">iterNext</span> <span class="o">=</span> <span class="n">iterStart</span><span class="p">;</span>
  <span class="o">++</span><span class="n">iterNext</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">iterNext</span> <span class="o">!=</span> <span class="n">iterEnd</span><span class="p">;</span> <span class="o">++</span><span class="n">iterStart</span><span class="p">,</span> <span class="o">++</span><span class="n">iterNext</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Point</span> <span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">iterStart</span><span class="p">;</span>
    <span class="n">Point</span> <span class="n">next</span>  <span class="o">=</span> <span class="o">*</span><span class="n">iterNext</span><span class="p">;</span>

    <span class="c1">// Find shortest distance from point to the polyline line</span>
    <span class="n">Vector</span> <span class="n">m</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">Vector</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">length2</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">TOLERANCE_MIN</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">double</span> <span class="n">t0</span> <span class="o">=</span> <span class="n">Dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">Dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t0</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">t0</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Shortest distance is inside segment; this is the closest point</span>
        <span class="n">min_p</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">t0</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
        <span class="n">XP</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">min_p</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">double</span> <span class="n">min_d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">xp</span> <span class="o">:</span>  <span class="n">XP</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Compute distance sq</span>
    <span class="kt">double</span> <span class="n">dSq</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">xp</span><span class="p">).</span><span class="n">length2</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dSq</span> <span class="o">&lt;</span> <span class="n">min_d</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">min_d</span> <span class="o">=</span> <span class="n">dSq</span><span class="p">;</span>
      <span class="n">min_p</span> <span class="o">=</span> <span class="n">xp</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h5 id="an-animation-of-the-closest-point-algorithm">An animation of the closest point algorithm</h5>
<div class="yield-surf-canvas">
</div>

<h4 id="remarks">Remarks</h4>
<p>This geometric algorithm is remarkably accurate and avoids complications associated with
computing gradients in the transformed space.  In the next article we will discuss
how the animation in this was created.</p>

<script src="https://d3js.org/d3.v4.min.js"></script>

<script src="/ParSim/assets/js/yieldsurface.js"></script>

<script>
  d3.json("/ParSim/assets/json/yieldSurfData.json", drawYieldSurface);
</script>


        
      </section>

      <footer class="page__meta">
        
        


  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/ParSim/categories/#algorithm" class="page__taxonomy-item" rel="tag">Algorithm</a><span class="sep">, </span>
    
      
      
      <a href="/ParSim/categories/#mechanics" class="page__taxonomy-item" rel="tag">Mechanics</a><span class="sep">, </span>
    
      
      
      <a href="/ParSim/categories/#plasticity" class="page__taxonomy-item" rel="tag">Plasticity</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2017-03-31T23:30:00+13:00">March 31, 2017</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=Geometric+closest+point+return+algorithm%20https%3A%2F%2Fbbanerjee.github.io%2FParSim%2Fmechanics%2Fplasticity%2Falgorithm%2Fgeometric-closest-point-return%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fbbanerjee.github.io%2FParSim%2Fmechanics%2Fplasticity%2Falgorithm%2Fgeometric-closest-point-return%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fbbanerjee.github.io%2FParSim%2Fmechanics%2Fplasticity%2Falgorithm%2Fgeometric-closest-point-return%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/ParSim/mechanics/plasticity/algorithm/closest-point-return/" class="pagination--pager" title="Exploring closest point return plasticity
">Previous</a>
    
    
      <a href="/ParSim/javascript/d3js/d3-animation-closest-point-return/" class="pagination--pager" title="Creating an animation with d3.js
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ParSim/fem/meshing/gmsh/gmsh-meshing-for-code-aster/" rel="permalink">Meshes with different element topologies in gmsh (for Code-Aster)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          39 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">We have been translating a few Code-Aster verification test manuals into English.
The process is not just a straightforward translation of the text in the Fr...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ParSim/fem/meshing/gmsh/quadrlateral-meshing-with-gmsh/" rel="permalink">Creating quadrilateral surface meshes with gmsh
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          21 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">The Code-Aster cooling tower modal analysis validation test
FORMA11c comes with a quadrilateral mesh provided by Code-Aster.
Tips on quadrilateral meshing wi...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ParSim/fem/cracks/python/salome-meca/code-aster/inspecting-and-manipulating-meshes/" rel="permalink">Inspecting and manipulating meshes in Salome-Meca for Code-Aster
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          30 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">In this article, I will discuss how elements can be selected from deep inside a 3D mesh
in the Salome-Meca environment and manipulated with Python scripts.

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/ParSim/vaango/compiling-vaango-on-a-cray/" rel="permalink">Compiling and running the MPM code Vaango on a Cray
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Introduction

One of the reasons I switched to cmake for my builds was the need to compile my
Vaango code on a BlueGene/Q system.  The code was previously co...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
    

    <li><a href="/ParSim/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2022 Biswajit Banerjee. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/ParSim/assets/js/main.min.js"></script>










  </body>
</html>
