/*
 * The MIT License
 *
 * Copyright (c) 2014-2025 Biswajit Banerjee, Parresia Research Ltd, NZ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include <StandAlone/tools/uda2vtk/UDAInfoData.h>
#include <Core/DataArchive/DataArchive.h>

#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <iomanip>
#include <cstdio>
#include <algorithm>

using namespace Vaango;

const double NAN_REPLACE_VAL=1.0E9;

ReadUDA::ReadUDA() 
{
  d_useExtraCells = true;
  d_input_uda_name = "NoArchive";
  d_archive = nullptr;
  d_stepInfo = nullptr;
}

ReadUDA::ReadUDA(const std::string& input_uda_name) 
{
  d_useExtraCells = true;
  d_input_uda_name = input_uda_name;
  if (isUDAFile(d_input_uda_name)) {

    // use the folder name, not the index.xml file name to open the archive
    std::string folder(filename);
    size_t found = folder.find_last_of("/");
    folder = folder.substr(0, found);
    d_archive = scinew DataArchive(folder);

    // timestep times
    d_cycleTimes = getCycleTimes();

    // haven't loaded any timestep data yet
    d_stepInfo = nullptr;
    d_currTimestep = -1;
  } 
}

ReadUDA::~ReadUDA() 
{
  if (d_archive) delete d_archive;
  if (d_stepInfo) delete d_stepInfo;
}

/*!****************************************************************************
 *  Method: 
 *    isUDAFile
 *  Purpose:
 *    Verify that it is a UDA index.xml file:
 *    The 2nd line should look like this <Uintah_DataArchive>.
 *****************************************************************************/
bool
ReadUDA::isUDAFile(const std::string& fileName) 
{
  FILE * fp = fopen( filename, "r" );
  if( fp == nullptr ) {
    std::ostringstream error;
    error << "Failed to open file: " << filename;
    throw InvalidFilesExpection(error.str(), __FILE__, __LINE__);
  }

  char line[1024];
  char * result = fgets( line, 1024, fp );
  if( result ) { 
    result = fgets( line, 1024, fp );
  }

  string lineStr = line;
  if( !result || lineStr.find( "<Uintah_DataArchive>" ) == string::npos ) {
    std::ostringstream error;
    error << std::string(filename) << " does not appear to be a <Uintah_DataArchive>.";
    throw InvalidFilesExpection(error.str(), __FILE__, __LINE__);
  }
  fclose( fp );

  return true;
}

/*!****************************************************************************
 *  Method: 
 *    getCycleTimes
 *  Purpose:
 *    Get the time for each cycle.
 *****************************************************************************/
void
ReadUDA::getCycleTimes() 
{

  // Get the times and indices.
  std::vector<int> index;
  std::vector<double> d_cycleTimes;

  // query time info from dataarchive
  d_archive->queryTimesteps(index, d_cycleTimes);
} 

/*!**************************************************************************
 *  Method: readMesh
 *  Purpose:
 *      Reads the mesh associated with this file.  The mesh is returned as a
 *      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
 *      vtkUnstructuredGrid, etc).
 *  Arguments:
 *      timestate   The index of the timestate.  If GetNTimesteps returned
 *                  'N' time steps, this is guaranteed to be between 0 and N-1.
 *      domain      The index of the domain.  If there are NDomains, this
 *                  value is guaranteed to be between 0 and NDomains-1,
 *                  regardless of block origin.
 *      meshname    The name of the mesh of interest.  This can be ignored if
 *                  there is only one mesh.
 *  Programmer: sshankar -- generated by xml2avt
 *****************************************************************************/
vtkDataSet*
ReadUDA::readMesh(int timestate, int domain, const std::string& meshname)
{
  activateTimestep(timestate);

  int level, local_patch;
  getLevelAndLocalPatchNumber(domain, level, local_patch);

  // volume data
  if (meshName.find("Particle_Mesh") == string::npos) {

    LevelInfo &levelInfo = d_stepInfo->levelInfo[level];

    //get global bounds
    int glow[3], ghigh[3];
    getBounds(glow,ghigh,meshName,levelInfo);

    //get patch bounds
    int low[3], high[3];
    getBounds(low,high,meshName,levelInfo,local_patch);

    vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();

    int dims[3];
    for (int i=0; i<3; i++)
      dims[i] = high[i]-low[i]+1; // The +1 is important...
    rgrid->SetDimensions(dims);

    // need these to offset grid points in order to preserve face 
    // centered locations on node-centered domain.
    bool sfck[3] = {meshName.find("SFCX") != string::npos,
                    meshName.find("SFCY") != string::npos,
                    meshName.find("SFCZ") != string::npos};

    // Set the coordinates of the grid points in each direction.
    for (int c=0; c<3; c++) {
      vtkFloatArray *coords = vtkFloatArray::New(); 
      coords->SetNumberOfTuples(dims[c]); 
      float *array = (float *)coords->GetVoidPointer(0); 
      for (int i=0; i<dims[c]; i++)
      {
        // Face centered data gets shifted towards -inf by half a cell.
        // Boundary patches are special shifted to preserve global domain.
        // Internal patches are always just shifted.
        float face_offset=0;
        if (sfck[c]) {
          if (i==0)
            if (low[c]==glow[c]) // patch is on low boundary
              face_offset = 0.0;
            else
              face_offset = -0.5;       // patch boundary is internal to the domain
          else if (i==dims[c]-1)
            if (high[c]==ghigh[c]) // patch is on high boundary
              if (levelInfo.periodic[c])  // periodic means one less value in the face-centered direction
                face_offset = 0.0;
              else
                face_offset = -1;
            else                        // patch boundary is internal to the domain
              face_offset = -0.5;
          else
            face_offset = -0.5;
        }
        array[i] = levelInfo.anchor[c] +
          (i + low[c] + face_offset) * levelInfo.spacing[c];
      }

      switch(c) {
      case 0:
        rgrid->SetXCoordinates(coords); break;
      case 1:
        rgrid->SetYCoordinates(coords); break;
      case 2:
        rgrid->SetZCoordinates(coords); break;
      }

      coords->Delete();
    }

    return rgrid;
  } else if (meshName.find("Particle_Mesh") != string::npos) {// particle data

    size_t found = meshName.find("/");
    string matl = meshName.substr(found + 1);

    int matlNo = -1;
    if (matl.compare("*") != 0)
      matlNo = atoi(matl.c_str());

    // we always want p.x when setting up the mesh
    string vars = "p.x";

    ParticleDataRaw *pd = getParticleData(level, local_patch, vars, matlNo, timestate);

    // Create the vtkPoints object and copy points into it.
    vtkDoubleArray *doubleArray = vtkDoubleArray::New();
    doubleArray->SetNumberOfComponents(3);
    doubleArray->SetArray(pd->data, pd->num*pd->components, 0);

    vtkPoints *points = vtkPoints::New();
    points->SetData(doubleArray);
    doubleArray->Delete();

    // Create a vtkUnstructuredGrid to contain the point cells. 
    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New(); 
    ugrid->SetPoints(points); 
    points->Delete(); 
    ugrid->Allocate(pd->num); 
    vtkIdType onevertex; 

    for(int i = 0; i < pd->num; ++i) {
      onevertex = i; 
      ugrid->InsertNextCell(VTK_VERTEX, 1, &onevertex); 
    } 

    // don't delete pd->data - vtk owns it now!
    delete pd;

    return ugrid;
  }

  return nullptr;
}


/*!****************************************************************************
 *  Method: 
 *    readVectorVar
 *  Purpose:
 *    Reads a vector variable associated with this file.  Although VTK has
 *    support for many different types, the best bet is vtkDoubleArray, since
 *    that is supported everywhere through VisIt.
 *  Arguments:
 *    timestate  The index of the timestate.  If GetNTimesteps returned
 *                 'N' time steps, this is guaranteed to be between 0 and N-1.
 *    domain     The index of the domain.  If there are NDomains, this
 *                 value is guaranteed to be between 0 and NDomains-1,
 *                 regardless of block origin.
 *    varname    The name of the variable requested.
 *  Programmer: sshankar
 *****************************************************************************/
vtkDataArray*
readUDA::readVectorVar(int timestate, int domain, const std::string& varname)
{
  return readVar(timestate, domain, varname);
}

/*!****************************************************************************
 *  Method: 
 *    ReadVar
 *  Purpose:
 *    Gets a scalar variable associated with this file.  Although VTK has
 *    support for many different types, the best bet is vtkDoubleArray, since
 *    that is supported everywhere through VisIt.
 *  Arguments:
 *    timestate  The index of the timestate.  If GetNTimesteps returned
 *                 'N' time steps, this is guaranteed to be between 0 and N-1.
 *    domain     The index of the domain.  If there are NDomains, this
 *                 value is guaranteed to be between 0 and NDomains-1,
 *                 regardless of block origin.
 *    varname    The name of the variable requested.
 *  Programmer: sshankar -- generated by xml2avt
 *****************************************************************************/
vtkDataArray*
readUDA::readVar(int timestate, int domain, const std::string& varname)
{
  // Get the data archive and grid for the current time step
  activateTimestep(timestate);

  // Find the material ID
  bool isParticleVar = false;
  size_t found = varName.find("/");
  std::string tmpVarName = varName;
    
  std::string matl = varName.substr(found + 1);
  varName = varName.substr(0, found);
    
  // Find if we are dealing with particle variables
  std::string varType="CC_Mesh";
  if (strcmp(varname, "proc_id")!=0) {
    for (int k=0; k<(int)d_stepInfo->varInfo.size(); k++) {
      if (d_stepInfo->varInfo[k].name == varName) {
        varType = d_stepInfo->varInfo[k].type;
        if (d_stepInfo->varInfo[k].type.find("ParticleVariable") != string::npos) {
          isParticleVar = true;
          break;
        }
      }
    }
  }

  // Set up a vtkDoubleArray to be returned
  vtkDoubleArray *rv = vtkDoubleArray::New();

  // Get the levl and patch
  int level, local_patch;
  getLevelAndLocalPatchNumber(domain, level, local_patch);

  // First read the CC/NC data
  if (!isParticleVar) { 

    LevelInfo &levelInfo = d_stepInfo->levelInfo[level];
    PatchInfo &patchInfo = levelInfo.patchInfo[local_patch];

    int qlow[3], qhigh[3]; // region we're going to ask uintah for (from qlow to qhigh-1)
    patchInfo.getBounds(qlow, qhigh, varType);

    GridDataRaw *gd=nullptr;

    if (strcmp(varname, "proc_id")==0) {
      gd = new GridDataRaw;
      for (int i=0; i<3; i++) {
        gd->low[i ] = qlow[i];
        gd->high[i] = qhigh[i];
      }
      gd->components=1;

      int ncells = (qhigh[0]-qlow[0])*(qhigh[1]-qlow[1])*(qhigh[2]-qlow[2]);
      gd->data = new double[ncells];
      for (int i=0; i<ncells; i++) 
        gd->data[i] = patchInfo.getProcId();
    } else {
      gd = getGridData(level, local_patch, varName, 
                       std::stoi(matl), timestate, qlow, qhigh);
    }

    int n = (qhigh[0]-qlow[0])*(qhigh[1]-qlow[1])*(qhigh[2]-qlow[2]);

    replaceNaNs(n*gd->components, gd->data, level, local_patch);

    rv->SetNumberOfComponents(gd->components);
    rv->SetArray(gd->data, n*gd->components, 0);

    // don't delete gd->data - vtk owns it now!
    delete gd;

  } else { // particle data

    int matlNo = -1;
    if (matl.compare("*") != 0) matlNo = std::stoi(matl);

    ParticleDataRaw* pd = 
     getParticleData(level, local_patch, varName, matlNo, timestate);

    replaceNaNs(pd->num*pd->components, pd->data, level, local_patch);

    rv->SetNumberOfComponents(pd->components);
    rv->SetArray(pd->data, pd->num*pd->components, 0);

    // don't delete pd->data - vtk owns it now!
    delete pd;
  }

  return rv;
}


/*****************************************************************************
 * Method: activateTimestep
 * Purpose: 
 *   Get ready to read data for the given timestep
 *****************************************************************************/
void
readUDA::activateTimestep(int ts)
{
  if (d_currTimestep == ts) return;

  // get the uda grid for the new timestep
  setGrid(ts);

  setTimestepInfo(ts);

  d_currTimestep = ts; 
}

/*****************************************************************************
 * Method: setGrid
 * Purpose: 
 *   Get the grid for the current timestep, so we don't have to query
 *   it over and over.  
 *****************************************************************************/
void
ReadUDA::setGrid(int timeStepNo) 
{
  d_grid = d_archive->queryGrid(timeStepNo);
}

/*****************************************************************************
 * Method: setTimestepInfo
 * Purpose: 
 *   Get all the information that may be needed for the current timestep,
 *   including variable/material info, and level/patch info
 *****************************************************************************/
void
ReadUDA::setTimestepInfo(int timestep)
{

  // Reset timestep info
  if (d_stepInfo) {
    delete d_stepInfo;
  }
  d_stepInfo = new TimestepInfo();

  int numLevels = d_grid->numLevels();
  d_stepInfo->levelInfo.resize(numLevels);

  // get variable information
  std::vector<std::string> vars;
  std::vector<const Uintah::TypeDescription*> types;
  d_archive->queryVariables(vars, types);
  d_stepInfo->varInfo.resize(vars.size());

  for (unsigned int i=0; i<vars.size(); i++) {

    VariableInfo &varInfo = d_stepInfo->varInfo[i];

    varInfo.name = vars[i];
    varInfo.type = types[i]->getName();

    // query each level for material info until we find something
    for (int l=0; l<numLevels; l++) {
      LevelP level = d_grid->getLevel(l);
      const Patch* patch = *(level->patchesBegin());
      ConsecutiveRangeSet matls = d_archive->queryMaterials(vars[i], patch, timestep);
      if (matls.size() > 0) {

        // copy the list of materials
        for (ConsecutiveRangeSet::iterator matlIter = matls.begin();
             matlIter != matls.end(); matlIter++)
          varInfo.materials.push_back(*matlIter);

        // don't query on any more levels
        break;
      }
    }
  }

  // get level information
  for (int l=0; l<numLevels; l++) {
    LevelInfo &levelInfo = d_stepInfo->levelInfo[l];
    LevelP level = d_grid->getLevel(l);

    copyIntVector(levelInfo.refinementRatio, level->getRefinementRatio());
    copyVector(levelInfo.spacing, level->dCell());
    copyVector(levelInfo.anchor, level->getAnchor());
    copyIntVector(levelInfo.periodic, level->getPeriodicBoundaries());

    // patch info
    int numPatches = level->numPatches();
    levelInfo.patchInfo.resize(numPatches);

    for (int p=0; p<numPatches; p++) {
      const Patch* patch = level->getPatch(p);
      PatchInfo &patchInfo = levelInfo.patchInfo[p];

      // If the user wants to see extra cells, just include them and let VisIt believe they are
      // part of the original data. This is accomplished by setting <meshtype>_low and
      // <meshtype>_high to the extra cell boundaries so that VisIt is none the wiser.
      if (d_useExtraCells) {
        patchInfo.setBounds(&patch->getExtraCellLowIndex()[0],
                            &patch->getExtraCellHighIndex()[0],"CC_Mesh");
        patchInfo.setBounds(&patch->getExtraNodeLowIndex()[0],
                            &patch->getExtraNodeHighIndex()[0],"NC_Mesh");
        patchInfo.setBounds(&patch->getExtraSFCXLowIndex()[0],
                            &patch->getExtraSFCXHighIndex()[0],"SFCX_Mesh");
        patchInfo.setBounds(&patch->getExtraSFCYLowIndex()[0],
                            &patch->getExtraSFCYHighIndex()[0],"SFCY_Mesh");
        patchInfo.setBounds(&patch->getExtraSFCZLowIndex()[0],
                            &patch->getExtraSFCZHighIndex()[0],"SFCZ_Mesh");
      } else {
        patchInfo.setBounds(&patch->getCellLowIndex()[0],
                            &patch->getCellHighIndex()[0],"CC_Mesh");
        patchInfo.setBounds(&patch->getNodeLowIndex()[0],
                            &patch->getNodeHighIndex()[0],"NC_Mesh");
        patchInfo.setBounds(&patch->getSFCXLowIndex()[0],
                            &patch->getSFCXHighIndex()[0],"SFCX_Mesh");
        patchInfo.setBounds(&patch->getSFCYLowIndex()[0],
                            &patch->getSFCYHighIndex()[0],"SFCY_Mesh");
        patchInfo.setBounds(&patch->getSFCZLowIndex()[0],
                            &patch->getSFCZHighIndex()[0],"SFCZ_Mesh");
      }

      //set processor id
      patchInfo.setProcId(d_archive->queryPatchwiseProcessor(patch, timestep));
    }
  }

  return;
}

/*!****************************************************************************
 *  Method: 
 *    getLevelAndLocalPatchNumber
 *  Purpose:
 *      Translates the global patch identifier to a refinement level and patch
 *      number local to that refinement level.
 *  Programmer: sshankar, taken from implementation of the plugin, CHOMBO
 *****************************************************************************/
void
readUDA::getLevelAndLocalPatchNumber(int global_patch, 
                                     int &level, int &local_patch)
{
  int num_levels = d_stepInfo->levelInfo.size();
  int num_patches = 0;
  int tmp = global_patch;
  level = 0;
  while (level < num_levels) {
    num_patches = d_stepInfo->levelInfo[level].patchInfo.size();
    if (tmp < num_patches)
      break;
    tmp -= num_patches;
    level++;
  }
  local_patch = tmp;
}


/*!****************************************************************************
 *  Method: 
 *    getGridData
 *  Purpose:
 *      Read Grid data from the data archive
 *  Programmer: sshankar
 *****************************************************************************/
GridDataRaw*
ReadUDA::getGridData(int level_i, int patch_i, const std::string& variable_name,
                     int material, int timestep, int low[3], int high[3]) 
{

  LevelP level = d_grid->getLevel(level_i);
  const Patch *patch = level->getPatch(patch_i);

  // figure out what the type of the variable we're querying is
  std::vector<std::string> vars;
  std::vector<const Uintah::TypeDescription*> types;
  d_archive->queryVariables(vars, types);

  const Uintah::TypeDescription* maintype = nullptr;
  const Uintah::TypeDescription* subtype = nullptr;

  for (unsigned int i=0; i<vars.size(); i++) {
    if (vars[i] == variable_name) {
      maintype = types[i];
      subtype = maintype->getSubType();
    }
  }

  if (!maintype || !subtype) {
    cerr<<"couldn't find variable " << variable_name<<endl;
    return nullptr;
  }

  switch (maintype->getType()) {

  case Uintah::TypeDescription::Type::CCVariable:
    return getGridDataMainType<CCVariable>(patch, level, variable_name, material, timestep, 
                                           low, high, subtype);

  case Uintah::TypeDescription::Type::NCVariable:
    return getGridDataMainType<NCVariable>(patch, level, variable_name, material, timestep, 
                                           low, high, subtype);

  case Uintah::TypeDescription::Type::SFCXVariable:
    return getGridDataMainType<SFCXVariable>(patch, level, variable_name, material, timestep, 
                                             low, high, subtype);

  case Uintah::TypeDescription::Type::SFCYVariable:
    return getGridDataMainType<SFCYVariable>(patch, level, variable_name, material, timestep, 
                                             low, high, subtype);

  case Uintah::TypeDescription::Type::SFCZVariable:
    return getGridDataMainType<SFCZVariable>(patch, level, variable_name, material, timestep, 
                                             low, high, subtype);

  default:
    std::cerr <<  "Type is unknown.\n";
    return nullptr;
  }
}

/*!****************************************************************************
 *  Method: 
 *    getGridDataMainType
 *  Purpose:
 *      Read Grid data from the data archive for each type
 *  Programmer: sshankar
 *****************************************************************************/
template<template<typename> class VAR>
GridDataRaw* 
ReadUDA::getGridDataMainType(const Patch *patch,
                             const LevelP level,
                             string variable_name,
                             int material,
                             int timestep,
                             int low[3],
                             int high[3],
                             const Uintah::TypeDescription *subtype) 
{
  switch (subtype->getType()) {

  case Uintah::TypeDescription::Type::double_type:
    return readGridData<VAR, double>(d_archive, patch, level, variable_name, material, 
                                     timestep, low, high);

  case Uintah::TypeDescription::Type::float_type:
    return readGridData<VAR, float>(d_archive, patch, level, variable_name, material, 
                                    timestep, low, high);

  case Uintah::TypeDescription::Type::int_type:
    return readGridData<VAR, int>(d_archive, patch, level, variable_name, material, 
                                  timestep, low, high);

  case Uintah::TypeDescription::Type::Vector:
    return readGridData<VAR, Vector>(d_archive, patch, level, variable_name, material, 
                                     timestep, low, high);

  case Uintah::TypeDescription::Type::Matrix3:
    return readGridData<VAR, Matrix3>(d_archive, patch, level, variable_name, material, 
                                      timestep, low, high);

  case Uintah::TypeDescription::Type::bool_type:
  case Uintah::TypeDescription::Type::short_int_type:
  case Uintah::TypeDescription::Type::long_type:

  case Uintah::TypeDescription::Type::long64_type:
    std::cerr <<  "Subtype " << subtype->getName() << " is not implemented...\n";
    return nullptr;

  default:
    std::cerr <<  "Unknown subtype\n";
    return nullptr;
  }
}

/*!****************************************************************************
 *  Method: 
 *    readGridData
 *  Purpose:
 *    Read the grid data for the given index range
 *  Returns:    none
 ****************************************************************************/
/////////////////////////////////////////////////////////////////////
template<template <typename> class VAR, typename T>
static GridDataRaw* 
ReadUDA::readGridData(DataArchive* archive,
                      const Patch *patch,
                      const LevelP level,
                      string variable_name,
                      int material,
                      int timestep,
                      int low[3],
                      int high[3]) 
{

  IntVector ilow(low[0], low[1], low[2]);
  IntVector ihigh(high[0], high[1], high[2]);

  // this queries the entire patch, including extra cells and boundary cells
  VAR<T> var;
  archive->queryRegion(var, variable_name, material, level.get_rep(), timestep, ilow, ihigh);

  //  IntVector low = var.getLowIndex();
  //  IntVector high = var.getHighIndex();

  GridDataRaw *gd = new GridDataRaw;
  gd->components = numComponents<T>();
  for (int i=0; i<3; i++) {
    gd->low[i] = low[i];
    gd->high[i] = high[i];
  }

  int n = (high[0]-low[0])*(high[1]-low[1])*(high[2]-low[2]);
  gd->data = new double[n*gd->components];

  T *p=var.getPointer();
  for (int i=0; i<n; i++)
    copyComponents<T>(&gd->data[i*gd->components], p[i]);
  
  return gd;
}

/*!****************************************************************************
 *  Method: 
 *    getParticleData
 *  Purpose:
 *      Read Particle data from the data archive
 *  Programmer: sshankar
 *****************************************************************************/
ParticleDataRaw*
ReadUDA::getParticleData(int level_i,
                         int patch_i,
                         string variable_name,
                         int material,
                         int timestep) 
{

  LevelP level = d_grid->getLevel(level_i);
  const Patch *patch = level->getPatch(patch_i);

  // figure out what the type of the variable we're querying is
  std::vector<std::string> vars;
  std::vector<const Uintah::TypeDescription*> types;
  d_archive->queryVariables(vars, types);

  const Uintah::TypeDescription* maintype = nullptr;
  const Uintah::TypeDescription* subtype = nullptr;

  for (unsigned int i=0; i<vars.size(); i++) {
    if (vars[i] == variable_name) {
      maintype = types[i];
      subtype = maintype->getSubType();
    }
  }

  if (!maintype || !subtype) {
    cerr<<"couldn't find variable " << variable_name<<endl;
    return nullptr;
  }

  switch (subtype->getType()) {

  case Uintah::TypeDescription::Type::double_type:
    return readParticleData<double>(patch, variable_name, material, timestep);

  case Uintah::TypeDescription::Type::float_type:
    return readParticleData<float>(patch, variable_name, material, timestep);

  case Uintah::TypeDescription::Type::int_type:
    return readParticleData<int>(patch, variable_name, material, timestep);

  case Uintah::TypeDescription::Type::long64_type:
    return readParticleData<long64>(patch, variable_name, material, timestep);

  case Uintah::TypeDescription::Type::Point:
    return readParticleData<Point>(patch, variable_name, material, timestep);

  case Uintah::TypeDescription::Type::Vector:
    return readParticleData<Vector>(patch, variable_name, material, timestep);

  case Uintah::TypeDescription::Type::Matrix3:
    return readParticleData<Matrix3>(patch, variable_name, material, timestep);

  default:
    std::cerr <<  "Unknown subtype for particle data: " << subtype->getName() << "\n";
    return nullptr;
  }
}

/*!****************************************************************************
 *  Method: 
 *    readParticleData
 *  Purpose:
 *    Read all the particle data for a given patch.
 *  Programmer: sshankar
 *****************************************************************************/
template<typename T>
ReadUDA::ParticleDataRaw* readParticleData(const Patch* patch,
                                           const string& variable_name,
                                           int material,
                                           int timestep) 
{

  ParticleDataRaw *pd = new ParticleDataRaw;
  pd->components = numComponents<T>();
  pd->num = 0;

  // figure out which material we're interested in
  ConsecutiveRangeSet allMatls = d_archive->queryMaterials(variable_name, patch, timestep);

  ConsecutiveRangeSet matlsForVar;
  if (material<0) {
    matlsForVar = allMatls;
  } else {
    // make sure the patch has the variable - use empty material set if it doesn't
    if (allMatls.size()>0 && allMatls.find(material) != allMatls.end())
      matlsForVar.addInOrder(material);
  }

  // first get all the particle subsets so that we know how many total particles we'll have
  std::vector<ParticleVariable<T>*> particle_vars;
  for (auto matlIter = matlsForVar.begin(); matlIter != matlsForVar.end(); matlIter++ ) {
    int matl = *matlIter;

    ParticleVariable<T> *var = new ParticleVariable<T>;
    d_archive->query(*var, variable_name, matl, patch, timestep);

    particle_vars.push_back(var);
    pd->num += var->getParticleSubset()->numParticles();
  }

  // copy all the data
  int pi=0;
  pd->data = new double[pd->components * pd->num];
  for (unsigned int i=0; i<particle_vars.size(); i++) {
    for (auto p = particle_vars[i]->getParticleSubset()->begin();
         p != particle_vars[i]->getParticleSubset()->end(); ++p) {

      copyComponents<T>(&pd->data[pi*pd->components],
                        (*particle_vars[i])[*p]);
      pi++;
    }
  }

  // cleanup
  for (unsigned int i=0; i<particle_vars.size(); i++)
    delete particle_vars[i];

  return pd;
}

/*!****************************************************************************
 *  Method: 
 *      replaceNaNs
 *  Purpose:
 *      Check for and replace about NaN values in the file with NAN_REPLACE_VAL.
 *  Arguments:
 *      num        data size
 *      data       data
 *      level      level that contains this patch
 *      patch      patch that contains these cells
 *  Returns:    none
 ****************************************************************************/
void
readUDA::replaceNaNs(int num, double* data, int level, int patch)
{
  // replace nans with a large negative number
  std::vector<int> nanCells;
  for (int i=0; i<num; i++) {
    if (std::isnan(data[i])) {
      data[i] = NAN_REPLACE_VAL;
      nanCells.push_back(i);
    }
  }

  if (!nanCells.empty()) {
    std::stringstream sstr;
    sstr << "NaNs exist in this file (patch "<<patch<<" of level "<<level
         <<"). They have been replaced by the value "<< NAN_REPLACE_VAL<<".";
    if ((int)nanCells.size()>40) {
      sstr<<"\nFirst 20: ";
      for (int i=0;i<(int)nanCells.size() && i<20;i++)
        sstr<<nanCells[i]<<",";
      sstr<<"\nLast 20: ";
      for (int i=(int)nanCells.size()-21;i<(int)nanCells.size();i++)
        sstr<<nanCells[i]<<",";
    } else {
      for (int i=0;i<(int)nanCells.size();i++)
        sstr<<nanCells[i]<<((int)nanCells.size()!=(i+1)?",":".");
    }
  }
}
